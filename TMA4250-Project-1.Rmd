---
title: "TMA4250-Project-1"
author: "Ole Riddervold, Ole Kristian Skogly"
date: "2023-02-07"
output: html_document
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# install.packages("geoR")
# install.packages("akima")
# install.packages("fields")
# install.packages("ggplot2")
# install.packages("MASS")

library(geoR)
library(akima)
library(fields)
library(ggplot2)
library(MASS)
library(bessel)
library(ggplot2)
library(plotrix)
```

# Problem 1

## a)
```{r 1b1}
alpha = c(1,1.9)
a1 = 10
h <- seq(0, 50, by=0.1)
# Power Exponential with power alpha=1 and spatial scale a=10
corr_funcexp1 <- function(h) {
  exp(-(h/a1)^(alpha[1]))
}

# Power Exponential with power alpha=1.9 and spatial scale a=10
corr_funcexp2 <- function(h) {
  exp(-(h/a1)^(alpha[2]))
}

nu = c(1,3)
a2 = 20

Mattern <- function(h, nu, a2) {
  (2^(1-nu) / gamma(nu)) * ((h*sqrt(8*nu))/a2)^nu * besselK(sqrt(8*nu)*h/a2, nu)
}

#Mattern with smoothness nu=1
corr_funcmatern1 = Mattern(h, nu[1], a2)

#Mattern with smoothness nu=3
corr_funcmatern2 = Mattern(h, nu[2], a2)

# Plot the functions
plot(h, corr_funcexp1(h), type="l", lwd=2, col="red", xlab="h", ylab="ρ(h)")+title("Spatial correlation functions")
lines(h, corr_funcexp2(h), lwd=2, col="blue")
lines(h, corr_funcmatern1, type="l", lwd=2, col="green")
lines(h, corr_funcmatern2, type="l", lwd=2, col="purple")

legend("topright", c("Power Exponential (α=1, a=10)", "Power Exponential (α=1.9, a=10)", "Mattern (ν=1, a=10)", "Mattern (ν=3, a=10)"),
       col=c("red", "blue", "green", "purple"), lwd=2, bg="white")

#Variance= 1
var1 = 1
#Semi-variogram function for the Power Exponential with power alpha=1 and spatial scale a=10
semivariogram_funcexp1 = var1*(1-corr_funcexp1(h))
#Semi-variogram function for the Power Exponential with power alpha=1.9 and spatial scale a=10
semivariogram_funcexp2 = var1*(1-corr_funcexp2(h))
#Semi-variogram function for #Mattern with smoothness nu=1
semivariogram_corr_funcmatern1 = var1*(1-corr_funcmatern1)
#Semi-variogram function for #Mattern with smoothness nu=3
semivariogram_corr_funcmatern2 = var1*(1-corr_funcmatern2)

# Plot the semivariograms for varians= 1
plot(h, semivariogram_funcexp1, type="l", lwd=2, col="red", xlab="h", ylab="γ(h)")+title("semi-variogram for var=1")
lines(h, semivariogram_funcexp2, lwd=2, col="blue")
lines(h, semivariogram_corr_funcmatern1, type="l", lwd=2, col="green")
lines(h, semivariogram_corr_funcmatern2, type="l", lwd=2, col="purple")

legend("bottomright", c("Power Exponential (α=1, a=10)", "Power Exponential (α=1.9, a=10)", "Mattern (ν=1, a=10)", "Mattern (ν=3, a=10)"),
       col=c("red", "blue", "green", "purple"), lwd=2, bg="white")

#Variance= 3
var2 = 3
#Semi-variogram function for the Power Exponential with power alpha=1 and spatial scale a=10
semivariogram_exp1 = var2*(1-corr_funcexp1(h))
#Semi-variogram function for the Power Exponential with power alpha=1.9 and spatial scale a=10
semivariogram_exp2 = var2*(1-corr_funcexp2(h))
#Semi-variogram function for #Mattern with smoothness nu=1
semivariogram_corr_matern1 = var2*(1-corr_funcmatern1)
#Semi-variogram function for #Mattern with smoothness nu=3
semivariogram_corr_matern2 = var2*(1-corr_funcmatern2)

# Plot the semivariograms for varians= 1
plot(h, semivariogram_exp1, type="l", lwd=2, col="red", xlab="h", ylab="γ(h)")+title("semi-variogram for var=3")
lines(h, semivariogram_exp2, lwd=2, col="blue")
lines(h, semivariogram_corr_matern1, type="l", lwd=2, col="green")
lines(h, semivariogram_corr_matern2, type="l", lwd=2, col="purple")

legend("bottomright", c("Power Exponential (α=1, a=10)", "Power Exponential (α=1.9, a=10)", "Mattern (ν=1, a=10)", "Mattern (ν=3, a=10)"),
       col=c("red", "blue", "green", "purple"), lwd=2, bg="white")

```
## b)
```{r 1b1}
matern_modified <- function(h, nu, a) {
  # Matern function as defined in lectures (based on matern from geoR)
  phi <- a/sqrt(8*nu)
  return(
    matern(h, phi, nu)
  )
}

s <- c(1:50)
N <- 4
nu <- 2
a <- 10
variance <- 2.5


dist_matrix <- as.matrix(dist(s, diag=TRUE, upper=TRUE))
mu <- rep(0, length(s))
Sigma <- variance*matern_modified(dist_matrix, nu, a)

x <- mvrnorm(n=N, mu, Sigma)
```

## c)

## d)

## e)

## f)

## g)


# Problem 2

## a)
```{r 1b1}
#Read the data from topo.dat file
data <- read.table("/Users/olekristianskogly/Documents/Romlig stat/topo.dat", sep = " ", header = TRUE)
ggplot (data, aes(x, y, color = z)) + geom_point()

# Interpolate the data
interp_obj <- interp(data$x, data$y, data$z)

# Plot the interpolated data with color bar
image.plot(interp_obj, main = "Interpolated Elevation", xlab = "x", ylab = "y")



interp_obj <- interp(data$x, data$y, data$z)

# Plot the heatmap
image(interp_obj, xlab = "x", ylab = "y", col = colorRampPalette(c("blue", "white", "red"))(30), 
      useRaster = TRUE)

# Add a contour plot on top of the heatmap
contour(interp_obj, add = TRUE, drawlabels = TRUE)
```

## b)

## c)

## d)

## e)

## f)


# Problem 3

## a)
```{r 1b1}
#Read the data from topo.dat file
data <- read.table("/Users/olekristianskogly/Documents/Romlig stat/topo.dat", sep = " ", header = TRUE)
ggplot (data, aes(x, y, color = z)) + geom_point()

# Interpolate the data
interp_obj <- interp(data$x, data$y, data$z)

# Plot the interpolated data with color bar
image.plot(interp_obj, main = "Interpolated Elevation", xlab = "x", ylab = "y")



interp_obj <- interp(data$x, data$y, data$z)

# Plot the heatmap
image(interp_obj, xlab = "x", ylab = "y", col = colorRampPalette(c("blue", "white", "red"))(30), 
      useRaster = TRUE)

# Add a contour plot on top of the heatmap
contour(interp_obj, add = TRUE, drawlabels = TRUE)
```
## b)

## c)
```{r 1b1}
# Convert the input data to a data frame
data_frame <- as.data.frame(data)

# Convert the data frame to a geodata object
temp <- as.geodata(data_frame)

# Create a regular grid of points to predict at
grid <- expand.grid(1:315,1:315)

# Use krige.conv to perform universal kriging and obtain predicted values
# krige.control is used to specify the kriging parameters
krigPred <- krige.conv(temp, locations = grid, krige = 
                         krige.control(type.krige = "ok", trend.d = "2nd", trend.l = "2nd",
                                       cov.pars = c(2500, 100), cov.model = "powered.exponential", kappa=1.5))

# Extract the predicted values from the krige object
prediction <- krigPred$predict

# Display the predicted values as an image plot
image.plot(interp(grid$Var1,grid$Var2,prediction))
```
## d)

## e)

## f)