---
title: "TMA4250-Project-1"
author: "Ole Riddervold, Ole Kristian Skogly"
date: "2023-02-07"
output: html_document
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(42)

# install.packages("geoR")
# install.packages("akima")
# install.packages("fields")
# install.packages("ggplot2")
# install.packages("MASS")
# install.packages("reshape2")
# install.packages("patchwork")
# install.packages("glue")

library(geoR)
library(akima)
library(fields)
library(ggplot2)
library(MASS)
library(reshape2)
library(patchwork)
library(glue)
library(tidyverse)
```

# Problem 1

## a)

## b)
```{r 1b0}
powered_exponential <- function(h, a, alpha) {
  # Powered exponential correlation function as defined in lectures
  return(
    exp(-(h/a)^alpha)
  )
}

matern_modified <- function(h, a, nu) {
  # Matern correlation function as defined in lectures (based on matern from geoR)
  phi <- a/sqrt(8*nu)
  return(
    matern(h, phi, nu)
  )
}
```

Defining parameters that are constant for the different cases:
```{r 1b1}
s <- c(1:50)
N <- 4
variance <- c(1, 5)
array_dims <- c(4, 4, length(s)) # Dimensions of the data-array to be plotted

dist_matrix <- as.matrix(dist(s, diag=TRUE, upper=TRUE))
mu <- rep(0, length(s))
```

Defining a function to plot the resulting 3D-array:
```{r 1b2_plot_fnc}
plot_realizations <- function(realizations) {
  
  plot <- do.call(wrap_plots, lapply(1:4, function(i) { # Using patchwork to create subplots using `wrap_plots`
    df <- realizations %>% melt %>% filter(Var1 == i)   # Converts the 3D array into a dataframe and filters on i
    ggplot(df) + geom_line(aes(Var3, value, group=Var2, color=factor(Var2))) +
      xlab("s") +labs(title=glue("Case {i}"), color="")
  }))
  
  return(plot)
}
```


Loop for powered exponential correlation function:
```{r 1b2_sim}
alpha <- c(1, 1.9)
exp_a <- 10
exp_realizations <- array(rep(0, prod(array_dims)), array_dims)

for (i in seq_along(variance)) {
  for (j in seq_along(alpha)) {
    Sigma <- variance[i]*powered_exponential(dist_matrix, exp_a, alpha[j])
    flattened_index <- 2*(i-1)%%2 + j
    exp_realizations[flattened_index, , ] <- as.array(mvrnorm(n=N, mu, Sigma))
  }
}
```

```{r 1b2_plot}
plot_realizations(exp_realizations)
```


Loop for matern correlation functions:
```{r 1b3_sim}
nu_values <- c(1, 3)
matern_a <- 10
matern_realizations <- array(rep(0, prod(array_dims)), array_dims)

for (i in seq_along(variance)) {
  for (j in seq_along(nu_values)) {
    Sigma <- variance[i]*matern(dist_matrix, matern_a, nu_values[j])
    flattened_index <- 2*(i-1)%%2 + j
    matern_realizations[flattened_index, , ] <- as.array(mvrnorm(n=N, mu, Sigma))
  }
}
```

```{r 1b3_plot}
plot_realizations(matern_realizations)
```

## c)

## d)
```{r 1d1}
Sigma <- variance[2]*matern(dist_matrix, matern_a, nu_values[2])
sigma_N <- c(0, 0.25)
Sigma_star <- Sigma[1:3, ]
Sigma_bar <- Sigma_star[, 1:3]

cond_sim <- matrix(0, nrow=2, ncol=50)
for (i in seq_along(sigma_N)) {
  y <- as.vector(mvrnorm(n=1, rep(0, 3), Sigma[1:3, 1:3] + sigma_N[i]*identity(3)))
  inv_mat <- solve(Sigma_bar + sigma_N[i]*identity(3))
  cond_mu <-  t(Sigma_star) %*% inv_mat %*% y
  cond_Sigma <- Sigma - t(Sigma_star) %*% inv_mat %*% Sigma_star
  cond_sim[i] <- rmvnorm(n=1, cond_mu, cond_Sigma)
}

cond_sim
```
## e)

## f)

## g)


# Problem 2

## a)

## b)

## c)

## d)

## e)

## f)


# Problem 3

## a)

## b)

## c)

## d)

## e)

## f)